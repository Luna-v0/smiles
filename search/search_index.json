{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>\ud83d\udea7 This project is currently under construction. \ud83d\udea7</p> <p>Welcome to the documentation for the Smiles Validator library, an essential part of a broader initiative focused on generating molecules using Generative AI techniques. This library is designed with two main components: the Validator and the Chemistry Module. The Validator is responsible for ensuring that SMILES (Simplified Molecular Input Line Entry System) strings are syntactically correct, using a robust parsing mechanism. Meanwhile, the Chemistry Module implements domain-specific chemical rules to guarantee the validity and consistency of molecular structures.</p> <p>The SMILES validation system is powered by a custom parser built with the SLY LALR(1) toolkit. The grammar used is adapted from the LL(1) parser described in this article and the OpenSMILES specification. For chemical data, such as atomic weights and valence information, the project retrieves information from the Bowserinator/Periodic-Table-JSON repository.</p>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li> Implementing aromacity<ul> <li> Check if rings are closed</li> <li> Check if all benzene examples are working properly</li> <li> Finish passing everything from the yacc to the parser manager</li> </ul> </li> <li> Analysing and Implementing RD filters</li> <li> Analysing more chemistry filters for the parser like: Filters 1 Filters 2</li> <li> Removing all shift/reduce conflicts</li> </ul>"},{"location":"reference/chem/","title":"Chemestry Module","text":""},{"location":"reference/chem/#chem.chem","title":"chem.chem","text":""},{"location":"reference/chem/#chem.chem.Atom","title":"Atom  <code>dataclass</code>","text":"<p>Class for handling only the periodic table atom properties, more properties from the periodic table lookup json could be added later.</p> Attribute <p>symbol: The symbol of the atom valency_layer: The last electron layer number electrons_in_valency: Amount of electrons in the valency layer layers: Indexes of all layers electrons_by_layer: Amount of electrons in each layer electron_configuration: The electron configuration of the atom</p> Source code in <code>src/chem/chem.py</code> <pre><code>@dataclass\nclass Atom:\n    \"\"\"\n    Class for handling only the periodic table atom properties, more properties from\n    the periodic table lookup json could be added later.\n\n    Attribute:\n        symbol: The symbol of the atom\n        valency_layer: The last electron layer number\n        electrons_in_valency: Amount of electrons in the valency layer\n        layers: Indexes of all layers\n        electrons_by_layer: Amount of electrons in each layer\n        electron_configuration: The electron configuration of the atom\n    \"\"\"\n\n    symbol: str\n    valency_layer: int = field(init=False)\n    electrons_in_valency: int = field(init=False)\n    layers: List[int] = field(init=False)\n    electrons_by_layers: List[int] = field(init=False)\n    electron_configuration: List[str] = field(default_factory=list)\n    aromatic: bool = field(default=False)\n\n    def __post_init__(self):\n        \"\"\"\n        Builds valency_layer and electrons_in_valency, also corrects the electron_configuration to list of strings\n        \"\"\"\n        if isinstance(self.electron_configuration, str):\n            self.electron_configuration = self.electron_configuration.split(\" \")\n\n        self.valency_layer = max([int(x[0]) for x in self.electron_configuration])\n        self.electrons_in_valency = sum(\n            [\n                int(x[2])\n                for x in self.electron_configuration\n                if int(x[0]) == self.valency_layer\n            ]\n        )\n\n        _layers = {int(x[0]) for x in self.electron_configuration}\n\n        self.layers = list(_layers)\n        self.layers.sort(reverse=True)\n\n        self.electrons_by_layers = [\n            sum([int(x[2]) for x in self.electron_configuration if x[0] == layer_n])\n            for layer_n in self.layers\n        ]\n\n    def __eq__(self, other):\n        if not isinstance(other, Atom):\n            return NotImplemented\n        return self.symbol == other.symbol\n\n    def __hash__(self):\n        return hash(self.symbol)\n</code></pre>"},{"location":"reference/chem/#chem.chem.Atom.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__()\n</code></pre> <p>Builds valency_layer and electrons_in_valency, also corrects the electron_configuration to list of strings</p> Source code in <code>src/chem/chem.py</code> <pre><code>def __post_init__(self):\n    \"\"\"\n    Builds valency_layer and electrons_in_valency, also corrects the electron_configuration to list of strings\n    \"\"\"\n    if isinstance(self.electron_configuration, str):\n        self.electron_configuration = self.electron_configuration.split(\" \")\n\n    self.valency_layer = max([int(x[0]) for x in self.electron_configuration])\n    self.electrons_in_valency = sum(\n        [\n            int(x[2])\n            for x in self.electron_configuration\n            if int(x[0]) == self.valency_layer\n        ]\n    )\n\n    _layers = {int(x[0]) for x in self.electron_configuration}\n\n    self.layers = list(_layers)\n    self.layers.sort(reverse=True)\n\n    self.electrons_by_layers = [\n        sum([int(x[2]) for x in self.electron_configuration if x[0] == layer_n])\n        for layer_n in self.layers\n    ]\n</code></pre>"},{"location":"reference/chem/#chem.chem.BracketAtom","title":"BracketAtom  <code>dataclass</code>","text":"<p>               Bases: <code>Atom</code></p> <p>Class for handling atoms with different properties than the default values of periodic table atoms.</p> <p>Attributes:</p> Name Type Description <code>isotope</code> <code>Optional[int]</code> <p>The isotope of the atom</p> <code>symbol</code> <code>str</code> <p>The symbol of the atom</p> <code>chiral</code> <code>Optional[int]</code> <p>The chiral of the atom</p> <code>hidrogens</code> <code>Optional[int]</code> <p>The amount of hydrogens in the atom</p> <code>charge</code> <code>Optional[int]</code> <p>The charge of the atom</p> <code>mol_map</code> <code>Optional[int]</code> <p>The map of the atom</p> Source code in <code>src/chem/chem.py</code> <pre><code>@dataclass\nclass BracketAtom(Atom):\n    \"\"\"\n\n    Class for handling atoms with different properties than the default values of periodic table atoms.\n\n    Attributes:\n        isotope: The isotope of the atom\n        symbol: The symbol of the atom\n        chiral: The chiral of the atom\n        hidrogens: The amount of hydrogens in the atom\n        charge: The charge of the atom\n        mol_map: The map of the atom\n    \"\"\"\n\n    hidrogens: Optional[int] = field(default=None)\n    charge: Optional[int] = field(default=None)\n    isotope: Optional[int] = field(default=None)\n    chiral: Optional[int] = field(default=None)\n    mol_map: Optional[int] = field(default=None)\n\n    def __post_init__(self):\n        \"\"\"\n        Create a Bracket Atom with the given symbol, charge and hidrogens.\n\n        Args:\n            isotope: The isotope of the atom\n            symbol: The symbol of the atom\n            chiral: The chiral of the atom\n            hcount: The amount of hydrogens in the atom\n            charge: The charge of the atom\n            mol_map: The map of the atom\n        \"\"\"\n        super().__post_init__()\n        self.solo_valency = self.compute_valency()\n\n    def _octate_rule(self, layer: int) -&gt; bool:\n        \"\"\"\n        Check if the atom is a noble gas or if it is a Helium\n\n        Args:\n            layer: The layer to check if it is a noble gas or Helium\n        Returns:\n            If the atom is a noble gas or Helium\n        \"\"\"\n        return self.electrons_by_layers[layer] == 8 or (\n            layer == len(self.electrons_by_layers) - 1\n            and self.electrons_by_layers[layer] == 2\n        )\n\n    def compute_valency(self) -&gt; bool:\n        \"\"\"\n        Check if the valency of the current atom would be stable given more charge and hidrogens\n\n        Returns:\n            If that kept the Atom with a stable valency\n        \"\"\"\n        if self.hidrogens is None:\n            self.hidrogens = 0\n        if self.charge is None:\n            self.charge = 0\n\n        acc = self.hidrogens - self.charge\n\n        if sum(self.electrons_by_layers) &lt; -acc:\n            return False\n\n        if acc &lt; 0:\n            return self._handle_negative_acc(acc)\n\n        return self._handle_positive_acc(acc)\n\n    def _handle_negative_acc(self, acc: int) -&gt; bool:\n        \"\"\"\n        Handle the case where the accumulated charge is negative (removing electrons).\n\n        Args:\n            acc: The accumulated charge to be handled.\n\n        Returns:\n            If the atom remains stable after removing electrons.\n        \"\"\"\n        for x in range(len(self.electrons_by_layers)):\n            electron = self.electrons_by_layers[x]\n\n            if electron &gt; -acc:\n                return self._octate_rule(x)\n\n            self.electrons_by_layers[x] = 0\n\n            acc += electron\n\n        # filter the layers that are not 0\n        self.electrons_by_layers = [x for x in self.electrons_by_layers if x != 0]\n        self.valency_layer = len(self.electrons_by_layers) - 1\n        self.electrons_in_valency = self.electrons_by_layers[0]\n\n        # if it just keeps removing electrons more than the maximum\n        return False\n\n    def _handle_positive_acc(self, acc: int) -&gt; bool:\n        \"\"\"\n        Handle the case where the accumulated charge is positive (adding electrons).\n\n        Args:\n            acc: The accumulated charge to be handled.\n\n        Returns:\n            If the atom remains stable after adding electrons and the amount of electrons.\n        \"\"\"\n        max_valency_per_layer = [2, 8, 18, 32, 32, 18, 8, 2]\n\n        # first lets try adding electrons to the valency layer\n        if (\n            self.electrons_in_valency + acc\n            &lt;= max_valency_per_layer[self.valency_layer - 1]\n        ):\n            return (\n                self.electrons_in_valency + acc\n                == max_valency_per_layer[self.valency_layer - 1]\n            )\n\n        acc -= max_valency_per_layer[self.valency_layer - 1] - self.electrons_in_valency\n        self.electrons_in_valency = max_valency_per_layer[self.valency_layer - 1]\n\n        # now we check if there is any layer left to add electrons\n        for x in range(len(self.electrons_by_layers)):\n            electron = self.electrons_by_layers[x]\n            max_electrons_current_layer = max_valency_per_layer[\n                len(self.electrons_by_layers) - 1\n            ]\n            if electron + acc &gt; max_electrons_current_layer:\n                # update the valency layer\n                self.valency_layer = len(self.electrons_by_layers) - 1\n                self.electrons_in_valency = electron + acc\n                self.electrons_by_layers.insert(electron + acc, 0)\n                return self._octate_rule(x)\n\n            acc -= electron\n            self.electrons_by_layers[x] = max_valency_per_layer[\n                len(self.electrons_by_layers) - 1\n            ]\n            self.electrons_by_layers.insert(self.electrons_by_layers[x], 0)\n\n        # if it just keeps adding electrons more than the maximum\n        for x in range(self.valency_layer, len(max_valency_per_layer)):\n            electron = self.electrons_by_layers[x]\n            if electron + acc &gt; max_valency_per_layer[x]:\n                # update the valency layer\n                self.valency_layer = len(self.electrons_by_layers) - 1\n                self.electrons_in_valency = self.electrons_by_layers[0]\n\n                return self._octate_rule(x)\n\n            acc -= electron\n            self.electrons_by_layers[x] = max_valency_per_layer[x]\n            self.electrons_by_layers.insert(max_valency_per_layer[x], 0)\n\n        return False\n</code></pre>"},{"location":"reference/chem/#chem.chem.BracketAtom.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__()\n</code></pre> <p>Create a Bracket Atom with the given symbol, charge and hidrogens.</p> <p>Parameters:</p> Name Type Description Default <code>isotope</code> <p>The isotope of the atom</p> required <code>symbol</code> <p>The symbol of the atom</p> required <code>chiral</code> <p>The chiral of the atom</p> required <code>hcount</code> <p>The amount of hydrogens in the atom</p> required <code>charge</code> <p>The charge of the atom</p> required <code>mol_map</code> <p>The map of the atom</p> required Source code in <code>src/chem/chem.py</code> <pre><code>def __post_init__(self):\n    \"\"\"\n    Create a Bracket Atom with the given symbol, charge and hidrogens.\n\n    Args:\n        isotope: The isotope of the atom\n        symbol: The symbol of the atom\n        chiral: The chiral of the atom\n        hcount: The amount of hydrogens in the atom\n        charge: The charge of the atom\n        mol_map: The map of the atom\n    \"\"\"\n    super().__post_init__()\n    self.solo_valency = self.compute_valency()\n</code></pre>"},{"location":"reference/chem/#chem.chem.BracketAtom.compute_valency","title":"compute_valency","text":"<pre><code>compute_valency() -&gt; bool\n</code></pre> <p>Check if the valency of the current atom would be stable given more charge and hidrogens</p> <p>Returns:</p> Type Description <code>bool</code> <p>If that kept the Atom with a stable valency</p> Source code in <code>src/chem/chem.py</code> <pre><code>def compute_valency(self) -&gt; bool:\n    \"\"\"\n    Check if the valency of the current atom would be stable given more charge and hidrogens\n\n    Returns:\n        If that kept the Atom with a stable valency\n    \"\"\"\n    if self.hidrogens is None:\n        self.hidrogens = 0\n    if self.charge is None:\n        self.charge = 0\n\n    acc = self.hidrogens - self.charge\n\n    if sum(self.electrons_by_layers) &lt; -acc:\n        return False\n\n    if acc &lt; 0:\n        return self._handle_negative_acc(acc)\n\n    return self._handle_positive_acc(acc)\n</code></pre>"},{"location":"reference/chem/#chem.chem.Chem","title":"Chem","text":"<p>Class for handling Chemistry Domain Logic.</p> <p>Attributes:</p> Name Type Description <code>organic_atoms</code> <p>A fixed list of all possible organic atoms</p> <code>pt_symbols</code> <p>All the periodic table symbols</p> <code>look_up_table</code> <p>A look up table for all atoms</p> Source code in <code>src/chem/chem.py</code> <pre><code>class Chem:\n    \"\"\"\n    Class for handling Chemistry Domain Logic.\n\n    Attributes:\n        organic_atoms: A fixed list of all possible organic atoms\n        pt_symbols: All the periodic table symbols\n        look_up_table: A look up table for all atoms\n    \"\"\"\n\n    def number_of_electrons_per_bond(self, bond: str) -&gt; int:\n        \"\"\"\n        Get the number of electrons per bond.\n\n        Args:\n            bond: The bond to get the number of electrons from.\n\n        Returns:\n            The number of electrons per bond.\n        \"\"\"\n        bonds = {\"=\": 2, \"#\": 3, \"$\": 4, \"/\": 1, \"\\\\\": 1, \"-\": 1, \".\": 0}\n\n        if bond in bonds:\n            return bonds[bond]\n\n        raise Exception(f\"Invalid Bond {bond}\")\n\n    def __init__(self, periodic_table_path=\"src/periodic-table-lookup.json\"):\n\n        upper_organic_atoms = {\"N\", \"O\", \"P\", \"H\", \"S\", \"F\", \"Cl\", \"Br\", \"I\", \"C\", \"B\"}\n\n        with open(periodic_table_path) as JSON:  # loads the periodic table json\n            look_up_table_json = dict(load(JSON))\n\n        # set of all organic atoms\n        self.organic_atoms = {\n            atom.lower() for atom in upper_organic_atoms\n        } | upper_organic_atoms\n\n        # set of all periodic table symbols\n        self.pt_symbols = [\n            look_up_table_json[x][\"symbol\"] for x in look_up_table_json[\"order\"]\n        ]\n\n        look_up_table_json.pop(\"order\")\n\n        # creates a look up table for all atoms\n        self.look_up_table = {\n            x[\"symbol\"]: Atom(\n                symbol=x[\"symbol\"], electron_configuration=x[\"electron_configuration\"]\n            )\n            for x in look_up_table_json.values()\n        }\n\n    def Atom(self, symbol: str, aromatic: bool = False) -&gt; Atom:\n        \"\"\"\n        Create an Atom with the given symbol, charge and hidrogens.\n\n        Args:\n            symbol: The symbol of the atom\n            chiral: The chiral of the atom\n            hcount: The amount of hydrogens in the atom\n            charge: The charge of the atom\n            map: The map of the atom\n        \"\"\"\n\n        if symbol.title() != symbol:\n            symbol = symbol.title()\n            print(symbol)\n\n        if symbol not in self.pt_symbols:\n            raise Exception(f\"Invalid Symbol {symbol}\")\n\n        base_atom = self.look_up_table[symbol]\n\n        return Atom(\n            symbol=symbol,\n            electron_configuration=base_atom.electron_configuration,\n            aromatic=aromatic,\n        )\n\n    def BracketAtom(self, symbol: str, **kwargs) -&gt; BracketAtom:\n        \"\"\"\n        Create a Bracket Atom with the given symbol, charge and hidrogens.\n\n        Args:\n            symbol: The symbol of the atom\n            chiral: The chiral of the atom\n            hcount: The amount of hydrogens in the atom\n            charge: The charge of the atom\n            map: The map of the atom\n        \"\"\"\n        if symbol not in self.pt_symbols:\n            raise Exception(f\"Invalid Symbol {symbol}\")\n\n        base_atom = self.look_up_table[symbol]\n\n        if symbol.title() != symbol:  # if the symbol is not lowercase\n            symbol = symbol.title()\n            kwargs[\"aromatic\"] = True\n\n        return BracketAtom(\n            symbol=symbol,\n            electron_configuration=base_atom.electron_configuration,\n            **kwargs,\n        )\n\n    def validate_valency_bracket(\n        self,\n        isotope: Optional[int],\n        symbol: str,\n        chiral: Optional[int],\n        hcount: Optional[int],\n        charge: Optional[int],\n        map: Optional[int],\n    ) -&gt; bool:\n        \"\"\"\n        Validate the valency of a single bracket atom (if it is not a part of a aromatic ring)\n        Args:\n            isotope: The isotope of the atom\n            symbol: The symbol of the atom\n            chiral: The chiral of the atom\n            hcount: The amount of hydrogens in the atom\n            charge: The charge of the atom\n            map: The map of the atom\n        Returns:\n            If the valency of the atom is valid\n        \"\"\"\n\n        return self.BracketAtom(\n            symbol=symbol,\n            charge=charge if charge is not None else 0,\n            hidrogens=hcount if hcount is not None else 0,\n        ).compute_valency()\n</code></pre>"},{"location":"reference/chem/#chem.chem.Chem.Atom","title":"Atom","text":"<pre><code>Atom(symbol: str, aromatic: bool = False) -&gt; Atom\n</code></pre> <p>Create an Atom with the given symbol, charge and hidrogens.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The symbol of the atom</p> required <code>chiral</code> <p>The chiral of the atom</p> required <code>hcount</code> <p>The amount of hydrogens in the atom</p> required <code>charge</code> <p>The charge of the atom</p> required <code>map</code> <p>The map of the atom</p> required Source code in <code>src/chem/chem.py</code> <pre><code>def Atom(self, symbol: str, aromatic: bool = False) -&gt; Atom:\n    \"\"\"\n    Create an Atom with the given symbol, charge and hidrogens.\n\n    Args:\n        symbol: The symbol of the atom\n        chiral: The chiral of the atom\n        hcount: The amount of hydrogens in the atom\n        charge: The charge of the atom\n        map: The map of the atom\n    \"\"\"\n\n    if symbol.title() != symbol:\n        symbol = symbol.title()\n        print(symbol)\n\n    if symbol not in self.pt_symbols:\n        raise Exception(f\"Invalid Symbol {symbol}\")\n\n    base_atom = self.look_up_table[symbol]\n\n    return Atom(\n        symbol=symbol,\n        electron_configuration=base_atom.electron_configuration,\n        aromatic=aromatic,\n    )\n</code></pre>"},{"location":"reference/chem/#chem.chem.Chem.BracketAtom","title":"BracketAtom","text":"<pre><code>BracketAtom(symbol: str, **kwargs) -&gt; BracketAtom\n</code></pre> <p>Create a Bracket Atom with the given symbol, charge and hidrogens.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The symbol of the atom</p> required <code>chiral</code> <p>The chiral of the atom</p> required <code>hcount</code> <p>The amount of hydrogens in the atom</p> required <code>charge</code> <p>The charge of the atom</p> required <code>map</code> <p>The map of the atom</p> required Source code in <code>src/chem/chem.py</code> <pre><code>def BracketAtom(self, symbol: str, **kwargs) -&gt; BracketAtom:\n    \"\"\"\n    Create a Bracket Atom with the given symbol, charge and hidrogens.\n\n    Args:\n        symbol: The symbol of the atom\n        chiral: The chiral of the atom\n        hcount: The amount of hydrogens in the atom\n        charge: The charge of the atom\n        map: The map of the atom\n    \"\"\"\n    if symbol not in self.pt_symbols:\n        raise Exception(f\"Invalid Symbol {symbol}\")\n\n    base_atom = self.look_up_table[symbol]\n\n    if symbol.title() != symbol:  # if the symbol is not lowercase\n        symbol = symbol.title()\n        kwargs[\"aromatic\"] = True\n\n    return BracketAtom(\n        symbol=symbol,\n        electron_configuration=base_atom.electron_configuration,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/chem/#chem.chem.Chem.number_of_electrons_per_bond","title":"number_of_electrons_per_bond","text":"<pre><code>number_of_electrons_per_bond(bond: str) -&gt; int\n</code></pre> <p>Get the number of electrons per bond.</p> <p>Parameters:</p> Name Type Description Default <code>bond</code> <code>str</code> <p>The bond to get the number of electrons from.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of electrons per bond.</p> Source code in <code>src/chem/chem.py</code> <pre><code>def number_of_electrons_per_bond(self, bond: str) -&gt; int:\n    \"\"\"\n    Get the number of electrons per bond.\n\n    Args:\n        bond: The bond to get the number of electrons from.\n\n    Returns:\n        The number of electrons per bond.\n    \"\"\"\n    bonds = {\"=\": 2, \"#\": 3, \"$\": 4, \"/\": 1, \"\\\\\": 1, \"-\": 1, \".\": 0}\n\n    if bond in bonds:\n        return bonds[bond]\n\n    raise Exception(f\"Invalid Bond {bond}\")\n</code></pre>"},{"location":"reference/chem/#chem.chem.Chem.validate_valency_bracket","title":"validate_valency_bracket","text":"<pre><code>validate_valency_bracket(isotope: Optional[int], symbol: str, chiral: Optional[int], hcount: Optional[int], charge: Optional[int], map: Optional[int]) -&gt; bool\n</code></pre> <p>Validate the valency of a single bracket atom (if it is not a part of a aromatic ring) Args:     isotope: The isotope of the atom     symbol: The symbol of the atom     chiral: The chiral of the atom     hcount: The amount of hydrogens in the atom     charge: The charge of the atom     map: The map of the atom Returns:     If the valency of the atom is valid</p> Source code in <code>src/chem/chem.py</code> <pre><code>def validate_valency_bracket(\n    self,\n    isotope: Optional[int],\n    symbol: str,\n    chiral: Optional[int],\n    hcount: Optional[int],\n    charge: Optional[int],\n    map: Optional[int],\n) -&gt; bool:\n    \"\"\"\n    Validate the valency of a single bracket atom (if it is not a part of a aromatic ring)\n    Args:\n        isotope: The isotope of the atom\n        symbol: The symbol of the atom\n        chiral: The chiral of the atom\n        hcount: The amount of hydrogens in the atom\n        charge: The charge of the atom\n        map: The map of the atom\n    Returns:\n        If the valency of the atom is valid\n    \"\"\"\n\n    return self.BracketAtom(\n        symbol=symbol,\n        charge=charge if charge is not None else 0,\n        hidrogens=hcount if hcount is not None else 0,\n    ).compute_valency()\n</code></pre>"},{"location":"reference/validator/","title":"Validator Module","text":""},{"location":"reference/validator/#validator.parser_manager","title":"validator.parser_manager","text":""},{"location":"reference/validator/#validator.parser_manager.ParserException","title":"ParserException  <code>dataclass</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception for parser errors.</p> <p>Parameters:</p> Name Type Description Default <code>rule</code> <code>str</code> <p>The rule that caused the error.</p> required <code>parameter</code> <code>str</code> <p>The parameter that caused the error.</p> required <code>message</code> <code>str</code> <p>The error message.</p> required Source code in <code>src/validator/parser_manager.py</code> <pre><code>@dataclass\nclass ParserException(Exception):\n    \"\"\"\n    Exception for parser errors.\n\n    Args:\n        rule: The rule that caused the error.\n        parameter: The parameter that caused the error.\n        message: The error message.\n    \"\"\"\n\n    rule: str\n    parameter: str\n    message: str\n</code></pre>"},{"location":"reference/validator/#validator.parser_manager.ParserManager","title":"ParserManager","text":"<p>Parser manager to parse the SMILES strings.</p> <p>Attributes:</p> Name Type Description <code>current_open_rnum</code> <p>The current open ring numbers.</p> <code>current_closed_rnum</code> <p>The current closed ring numbers.</p> <code>current_chain</code> <code>list[Atom]</code> <p>The current chain.</p> Source code in <code>src/validator/parser_manager.py</code> <pre><code>class ParserManager:\n    \"\"\"\n    Parser manager to parse the SMILES strings.\n\n    Attributes:\n        current_open_rnum: The current open ring numbers.\n        current_closed_rnum: The current closed ring numbers.\n        current_chain: The current chain.\n    \"\"\"\n\n    current_open_rnum = list()\n    current_closed_rnum = list()\n    current_chain: list[Atom] = list()\n\n    def __enter__(self):\n        \"\"\"\n        Initializes the parser manager.\n        \"\"\"\n        self._reset()\n        return self\n\n    def __exit__(self):\n        self._reset()\n\n    def _reset(self):\n        \"\"\"\n        Resets the parser manager to its initial state.\n        \"\"\"\n        self.current_open_rnum = list()\n        self.current_closed_rnum = list()\n        self.current_chain = list()\n\n    def chain(self, bond=None, atom=None, rnum=None, dot_proxy=None):\n\n        if bond is None:\n\n            if atom is not None:\n                return atom\n\n            if rnum is not None:\n                return rnum\n\n            return dot_proxy\n\n        if bond == \":\" and atom and type(atom) == str and atom[0].isupper():\n            raise Exception(\n                f\"Aromatic bond cannot be use with Uppercase and collon {atom}\"\n            )\n\n        # TODO: need to check if the atom is not bracketed too\n\n        return [atom, chem.number_of_electrons_per_bond(bond)]\n\n    def inner_branch(self, bond_dot=None, line=None, inner_branch=None):\n        \"\"\" \"\"\"\n        if bond_dot == \".\":\n            self.validate_branch()\n            self._reset()\n\n        pass\n\n    def validate_branch(self) -&gt; bool:\n        \"\"\"\n        Validates based on the current state of the parser manager\n        \"\"\"\n\n        if len(self.current_open_rnum) != 0:\n            raise ParserException(\n                rule=\"validate_branch\",\n                parameter=f\"{self.current_open_rnum}\",\n                message=\"Unclosed ring numbers\",\n            )\n\n        starting_aromacity = self.current_chain[0].aromatic\n        for atom in self.current_chain[1:]:\n            if atom.aromatic != starting_aromacity:\n                raise ParserException(\n                    rule=\"validate_branch\",\n                    parameter=f\"{atom}\",\n                    message=\"Aromaticity mismatch\",\n                )\n\n        return True\n\n    @fill_none\n    def internal_bracket(self, istope, symbol, chiral, hcount, charge, mol_map):\n        \"\"\"\n        Parses the internal bracket and checks for valency.\n        \"\"\"\n\n        br_atom = chem.BracketAtom(\n            isotope=istope,\n            symbol=symbol,\n            chiral=chiral,\n            hidrogens=hcount,\n            charge=charge,\n            mol_map=mol_map,\n        )\n\n        self.current_chain.append(br_atom)\n\n        return br_atom\n\n    @fill_none\n    def listify(self, base_element, recursion):\n        \"\"\"\n        Generic rule for dealing with rules in the following format:\n\n        x -&gt; y x\n        x -&gt; y\n        Args:\n            base_element: Base element.\n            recursion: The chain element.\n        Returns:\n            The parsed atom or chain branch.\n        \"\"\"\n        if recursion is None:\n            return base_element\n\n        if type(recursion) == list:\n            return [base_element] + recursion\n\n        return [base_element, recursion]\n\n    def atom(self, symbol_or_bracket: str):\n        \"\"\"\n        Parses the atom symbol or bracket and from this point on always returns the parser manager\n        Args:\n            symbol_or_bracket: The atom symbol or bracket atom.\n        Returns:\n            The atom\n        \"\"\"\n\n        # TODO maybe I'm missing to add to the chain here?\n\n        if type(symbol_or_bracket) != str:\n            return symbol_or_bracket\n\n        if len(symbol_or_bracket) == 1 or symbol_or_bracket in chem.organic_atoms:\n            return chem.Atom(symbol_or_bracket, aromatic=symbol_or_bracket.islower())\n\n        elem1, elem2 = symbol_or_bracket\n\n        if elem1 in chem.organic_atoms and elem2 in chem.organic_atoms:\n            return [elem1, elem2]\n\n        raise Exception(\n            f\"Inorganic Atom Outside Bracket {symbol_or_bracket} not allowed\"\n        )\n\n    @fill_none\n    def ring_number(\n        self,\n        ring_number_or_symbol: str,\n        ring_number1: Optional[str],\n        ring_number2: Optional[str],\n    ) -&gt; int:\n        \"\"\"\n        Parses the ring numbers provided.\n        Args:\n            ring_number_or_symbol: A number or the % symbol.\n            ring_number1: The first digit, if any.\n            ring_number2: The second digit, if any.\n        Returns:\n            The parsed ring number as an integer.\n        \"\"\"\n        rnum = -1\n        raiser = lambda msg: ParserException(\n            rule=\"ring_number\",\n            parameter=f\"{ring_number_or_symbol} {ring_number1} {ring_number2}\",\n            message=msg,\n        )\n\n        if ring_number_or_symbol == \"%\":\n            if ring_number1 is None:\n                raiser(msg=\"Ring number cannot be just '%'\")\n\n            digits = ring_number1 + (ring_number2 or \"\")\n            if not digits.isdigit():\n                raiser(msg=\"Ring number must be a digit or '%'\")\n            rnum = int(digits)\n        elif ring_number_or_symbol.isdigit():\n            if ring_number2 is not None:\n                raiser(\n                    msg=\"Ring number cannot have more than one digit after the first\"\n                )\n            digits = ring_number_or_symbol + (ring_number1 or \"\")\n            if not digits.isdigit():\n                raiser(\n                    msg=\"Ring number must be a digit or a number with a leading digit\"\n                )\n            rnum = int(digits)\n        else:\n            raiser(msg=\"Ring number must be a digit or a number with a leading digit\")\n\n        if rnum &lt; 1:\n            raiser(msg=\"Ring number must be greater than 0\")\n\n        if rnum in self.current_open_rnum:\n            self.current_open_rnum.remove(rnum)\n            self.current_closed_rnum.append(rnum)\n        elif rnum in self.current_closed_rnum:\n            raiser(\n                msg=\"Ring number already closed\",\n            )\n        else:\n            self.current_open_rnum.append(rnum)\n\n        return rnum\n\n    def int(self, digits: List[str]) -&gt; int:\n        \"\"\"\n        Parses the provided digits to an integer.\n        Args:\n            digits: The digits to be parsed.\n        Returns:\n            The parsed integer.\n        \"\"\"\n        return int(\"\".join(digits))\n\n    @fill_none\n    def hcount(self, _, digit: Optional[str]) -&gt; int:\n        \"\"\"\n        Parses the hydrogen count.\n        Args:\n            digit: The digit to be parsed.\n        Returns:\n            The parsed hydrogen count.\n        \"\"\"\n        if not digit.isdigit():\n            raise ParserException(\n                rule=\"hcount\",\n                parameter=digit,\n                message=\"Hydrogen count must be a digit\",\n            )\n\n        return int(digit) if digit else 1\n\n    @fill_none\n    def charge(self, charge1: str, charge2: Union[str, None, int]) -&gt; int:\n        \"\"\"\n        Parsers the charge string to an integer.\n        Args:\n            charge1: either \"+\" or \"-\".\n            charge2: either \"+\", \"-\", None or an integer.\n        Returns:\n            The parsed charge as an integer.\n        \"\"\"\n        if charge2 is None:\n            return 1 if charge1 == \"+\" else -1\n\n        if type(charge2) == str and charge2 != charge1:\n            raise ParserException(\n                rule=\"charge\",\n                parameter=f\"{charge1} {charge2}\",\n                message=\"Charge mismatch\",\n            )\n\n        if charge2 == \"-\":\n            return -2\n\n        if charge2 == \"+\":\n            return 2\n\n        if charge1 == \"-\":\n            return charge2 * -1\n\n        return charge2\n\n    @fill_none\n    def chiral(self, chiral1: str, chiral2: Optional[str]) -&gt; str:\n        \"\"\"\n        Fixes the current chiral rotation\n\n        Args:\n            chiral1: The first chiral symbol.\n            chiral2: The second chiral symbol, if any.\n        Returns:\n            The current chiral rotation.\n        \"\"\"\n        return \"counterclockwise\" if chiral2 else \"clockwise\"\n\n    @fill_none\n    def fifteen(self, digit1: str, digit2: Optional[str]) -&gt; int:\n        \"\"\"\n        Fixes fifteen as maximum value for valency\n        Args:\n            digit1: The first digit to be parsed.\n            digit2: The second digit to be parsed, if any.\n        Returns:\n            The parsed rules.\n        \"\"\"\n        if digit2:\n            x = int(digit1 + digit2)\n\n            if x &gt; 15:\n                raise ParserException(\n                    rule=\"fifteen\",\n                    parameter=f\"{digit1} {digit2}\",\n                    message=\"Cannot exceed 15\",\n                )\n            return x\n\n        return int(digit1)\n</code></pre>"},{"location":"reference/validator/#validator.parser_manager.ParserManager.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> <p>Initializes the parser manager.</p> Source code in <code>src/validator/parser_manager.py</code> <pre><code>def __enter__(self):\n    \"\"\"\n    Initializes the parser manager.\n    \"\"\"\n    self._reset()\n    return self\n</code></pre>"},{"location":"reference/validator/#validator.parser_manager.ParserManager.atom","title":"atom","text":"<pre><code>atom(symbol_or_bracket: str)\n</code></pre> <p>Parses the atom symbol or bracket and from this point on always returns the parser manager Args:     symbol_or_bracket: The atom symbol or bracket atom. Returns:     The atom</p> Source code in <code>src/validator/parser_manager.py</code> <pre><code>def atom(self, symbol_or_bracket: str):\n    \"\"\"\n    Parses the atom symbol or bracket and from this point on always returns the parser manager\n    Args:\n        symbol_or_bracket: The atom symbol or bracket atom.\n    Returns:\n        The atom\n    \"\"\"\n\n    # TODO maybe I'm missing to add to the chain here?\n\n    if type(symbol_or_bracket) != str:\n        return symbol_or_bracket\n\n    if len(symbol_or_bracket) == 1 or symbol_or_bracket in chem.organic_atoms:\n        return chem.Atom(symbol_or_bracket, aromatic=symbol_or_bracket.islower())\n\n    elem1, elem2 = symbol_or_bracket\n\n    if elem1 in chem.organic_atoms and elem2 in chem.organic_atoms:\n        return [elem1, elem2]\n\n    raise Exception(\n        f\"Inorganic Atom Outside Bracket {symbol_or_bracket} not allowed\"\n    )\n</code></pre>"},{"location":"reference/validator/#validator.parser_manager.ParserManager.charge","title":"charge","text":"<pre><code>charge(charge1: str, charge2: Union[str, None, int]) -&gt; int\n</code></pre> <p>Parsers the charge string to an integer. Args:     charge1: either \"+\" or \"-\".     charge2: either \"+\", \"-\", None or an integer. Returns:     The parsed charge as an integer.</p> Source code in <code>src/validator/parser_manager.py</code> <pre><code>@fill_none\ndef charge(self, charge1: str, charge2: Union[str, None, int]) -&gt; int:\n    \"\"\"\n    Parsers the charge string to an integer.\n    Args:\n        charge1: either \"+\" or \"-\".\n        charge2: either \"+\", \"-\", None or an integer.\n    Returns:\n        The parsed charge as an integer.\n    \"\"\"\n    if charge2 is None:\n        return 1 if charge1 == \"+\" else -1\n\n    if type(charge2) == str and charge2 != charge1:\n        raise ParserException(\n            rule=\"charge\",\n            parameter=f\"{charge1} {charge2}\",\n            message=\"Charge mismatch\",\n        )\n\n    if charge2 == \"-\":\n        return -2\n\n    if charge2 == \"+\":\n        return 2\n\n    if charge1 == \"-\":\n        return charge2 * -1\n\n    return charge2\n</code></pre>"},{"location":"reference/validator/#validator.parser_manager.ParserManager.chiral","title":"chiral","text":"<pre><code>chiral(chiral1: str, chiral2: Optional[str]) -&gt; str\n</code></pre> <p>Fixes the current chiral rotation</p> <p>Parameters:</p> Name Type Description Default <code>chiral1</code> <code>str</code> <p>The first chiral symbol.</p> required <code>chiral2</code> <code>Optional[str]</code> <p>The second chiral symbol, if any.</p> required <p>Returns:     The current chiral rotation.</p> Source code in <code>src/validator/parser_manager.py</code> <pre><code>@fill_none\ndef chiral(self, chiral1: str, chiral2: Optional[str]) -&gt; str:\n    \"\"\"\n    Fixes the current chiral rotation\n\n    Args:\n        chiral1: The first chiral symbol.\n        chiral2: The second chiral symbol, if any.\n    Returns:\n        The current chiral rotation.\n    \"\"\"\n    return \"counterclockwise\" if chiral2 else \"clockwise\"\n</code></pre>"},{"location":"reference/validator/#validator.parser_manager.ParserManager.fifteen","title":"fifteen","text":"<pre><code>fifteen(digit1: str, digit2: Optional[str]) -&gt; int\n</code></pre> <p>Fixes fifteen as maximum value for valency Args:     digit1: The first digit to be parsed.     digit2: The second digit to be parsed, if any. Returns:     The parsed rules.</p> Source code in <code>src/validator/parser_manager.py</code> <pre><code>@fill_none\ndef fifteen(self, digit1: str, digit2: Optional[str]) -&gt; int:\n    \"\"\"\n    Fixes fifteen as maximum value for valency\n    Args:\n        digit1: The first digit to be parsed.\n        digit2: The second digit to be parsed, if any.\n    Returns:\n        The parsed rules.\n    \"\"\"\n    if digit2:\n        x = int(digit1 + digit2)\n\n        if x &gt; 15:\n            raise ParserException(\n                rule=\"fifteen\",\n                parameter=f\"{digit1} {digit2}\",\n                message=\"Cannot exceed 15\",\n            )\n        return x\n\n    return int(digit1)\n</code></pre>"},{"location":"reference/validator/#validator.parser_manager.ParserManager.hcount","title":"hcount","text":"<pre><code>hcount(_, digit: Optional[str]) -&gt; int\n</code></pre> <p>Parses the hydrogen count. Args:     digit: The digit to be parsed. Returns:     The parsed hydrogen count.</p> Source code in <code>src/validator/parser_manager.py</code> <pre><code>@fill_none\ndef hcount(self, _, digit: Optional[str]) -&gt; int:\n    \"\"\"\n    Parses the hydrogen count.\n    Args:\n        digit: The digit to be parsed.\n    Returns:\n        The parsed hydrogen count.\n    \"\"\"\n    if not digit.isdigit():\n        raise ParserException(\n            rule=\"hcount\",\n            parameter=digit,\n            message=\"Hydrogen count must be a digit\",\n        )\n\n    return int(digit) if digit else 1\n</code></pre>"},{"location":"reference/validator/#validator.parser_manager.ParserManager.inner_branch","title":"inner_branch","text":"<pre><code>inner_branch(bond_dot=None, line=None, inner_branch=None)\n</code></pre> Source code in <code>src/validator/parser_manager.py</code> <pre><code>def inner_branch(self, bond_dot=None, line=None, inner_branch=None):\n    \"\"\" \"\"\"\n    if bond_dot == \".\":\n        self.validate_branch()\n        self._reset()\n\n    pass\n</code></pre>"},{"location":"reference/validator/#validator.parser_manager.ParserManager.int","title":"int","text":"<pre><code>int(digits: List[str]) -&gt; int\n</code></pre> <p>Parses the provided digits to an integer. Args:     digits: The digits to be parsed. Returns:     The parsed integer.</p> Source code in <code>src/validator/parser_manager.py</code> <pre><code>def int(self, digits: List[str]) -&gt; int:\n    \"\"\"\n    Parses the provided digits to an integer.\n    Args:\n        digits: The digits to be parsed.\n    Returns:\n        The parsed integer.\n    \"\"\"\n    return int(\"\".join(digits))\n</code></pre>"},{"location":"reference/validator/#validator.parser_manager.ParserManager.internal_bracket","title":"internal_bracket","text":"<pre><code>internal_bracket(istope, symbol, chiral, hcount, charge, mol_map)\n</code></pre> <p>Parses the internal bracket and checks for valency.</p> Source code in <code>src/validator/parser_manager.py</code> <pre><code>@fill_none\ndef internal_bracket(self, istope, symbol, chiral, hcount, charge, mol_map):\n    \"\"\"\n    Parses the internal bracket and checks for valency.\n    \"\"\"\n\n    br_atom = chem.BracketAtom(\n        isotope=istope,\n        symbol=symbol,\n        chiral=chiral,\n        hidrogens=hcount,\n        charge=charge,\n        mol_map=mol_map,\n    )\n\n    self.current_chain.append(br_atom)\n\n    return br_atom\n</code></pre>"},{"location":"reference/validator/#validator.parser_manager.ParserManager.listify","title":"listify","text":"<pre><code>listify(base_element, recursion)\n</code></pre> <p>Generic rule for dealing with rules in the following format:</p> <p>x -&gt; y x x -&gt; y Args:     base_element: Base element.     recursion: The chain element. Returns:     The parsed atom or chain branch.</p> Source code in <code>src/validator/parser_manager.py</code> <pre><code>@fill_none\ndef listify(self, base_element, recursion):\n    \"\"\"\n    Generic rule for dealing with rules in the following format:\n\n    x -&gt; y x\n    x -&gt; y\n    Args:\n        base_element: Base element.\n        recursion: The chain element.\n    Returns:\n        The parsed atom or chain branch.\n    \"\"\"\n    if recursion is None:\n        return base_element\n\n    if type(recursion) == list:\n        return [base_element] + recursion\n\n    return [base_element, recursion]\n</code></pre>"},{"location":"reference/validator/#validator.parser_manager.ParserManager.ring_number","title":"ring_number","text":"<pre><code>ring_number(ring_number_or_symbol: str, ring_number1: Optional[str], ring_number2: Optional[str]) -&gt; int\n</code></pre> <p>Parses the ring numbers provided. Args:     ring_number_or_symbol: A number or the % symbol.     ring_number1: The first digit, if any.     ring_number2: The second digit, if any. Returns:     The parsed ring number as an integer.</p> Source code in <code>src/validator/parser_manager.py</code> <pre><code>@fill_none\ndef ring_number(\n    self,\n    ring_number_or_symbol: str,\n    ring_number1: Optional[str],\n    ring_number2: Optional[str],\n) -&gt; int:\n    \"\"\"\n    Parses the ring numbers provided.\n    Args:\n        ring_number_or_symbol: A number or the % symbol.\n        ring_number1: The first digit, if any.\n        ring_number2: The second digit, if any.\n    Returns:\n        The parsed ring number as an integer.\n    \"\"\"\n    rnum = -1\n    raiser = lambda msg: ParserException(\n        rule=\"ring_number\",\n        parameter=f\"{ring_number_or_symbol} {ring_number1} {ring_number2}\",\n        message=msg,\n    )\n\n    if ring_number_or_symbol == \"%\":\n        if ring_number1 is None:\n            raiser(msg=\"Ring number cannot be just '%'\")\n\n        digits = ring_number1 + (ring_number2 or \"\")\n        if not digits.isdigit():\n            raiser(msg=\"Ring number must be a digit or '%'\")\n        rnum = int(digits)\n    elif ring_number_or_symbol.isdigit():\n        if ring_number2 is not None:\n            raiser(\n                msg=\"Ring number cannot have more than one digit after the first\"\n            )\n        digits = ring_number_or_symbol + (ring_number1 or \"\")\n        if not digits.isdigit():\n            raiser(\n                msg=\"Ring number must be a digit or a number with a leading digit\"\n            )\n        rnum = int(digits)\n    else:\n        raiser(msg=\"Ring number must be a digit or a number with a leading digit\")\n\n    if rnum &lt; 1:\n        raiser(msg=\"Ring number must be greater than 0\")\n\n    if rnum in self.current_open_rnum:\n        self.current_open_rnum.remove(rnum)\n        self.current_closed_rnum.append(rnum)\n    elif rnum in self.current_closed_rnum:\n        raiser(\n            msg=\"Ring number already closed\",\n        )\n    else:\n        self.current_open_rnum.append(rnum)\n\n    return rnum\n</code></pre>"},{"location":"reference/validator/#validator.parser_manager.ParserManager.validate_branch","title":"validate_branch","text":"<pre><code>validate_branch() -&gt; bool\n</code></pre> <p>Validates based on the current state of the parser manager</p> Source code in <code>src/validator/parser_manager.py</code> <pre><code>def validate_branch(self) -&gt; bool:\n    \"\"\"\n    Validates based on the current state of the parser manager\n    \"\"\"\n\n    if len(self.current_open_rnum) != 0:\n        raise ParserException(\n            rule=\"validate_branch\",\n            parameter=f\"{self.current_open_rnum}\",\n            message=\"Unclosed ring numbers\",\n        )\n\n    starting_aromacity = self.current_chain[0].aromatic\n    for atom in self.current_chain[1:]:\n        if atom.aromatic != starting_aromacity:\n            raise ParserException(\n                rule=\"validate_branch\",\n                parameter=f\"{atom}\",\n                message=\"Aromaticity mismatch\",\n            )\n\n    return True\n</code></pre>"},{"location":"reference/validator/#validator.parser_manager.fill_none","title":"fill_none","text":"<pre><code>fill_none(func)\n</code></pre> <p>Decorator to fill None values in the function arguments</p> Source code in <code>src/validator/parser_manager.py</code> <pre><code>def fill_none(func):\n    \"\"\"\n    Decorator to fill None values in the function arguments\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(self, *args, **kwargs):\n        needed = func.__code__.co_argcount - 1  # minus self\n        padded = (list(args) + [None] * needed)[:needed]\n        return func(self, *padded, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"reference/validator/#validator.yacc","title":"validator.yacc","text":""},{"location":"reference/validator/#validator.yacc.SmilesParser","title":"SmilesParser","text":"<p>               Bases: <code>Parser</code></p> <p>Parser using the SLY library to parse SMILES strings.</p> Source code in <code>src/validator/yacc.py</code> <pre><code>class SmilesParser(Parser):\n    \"\"\"\n    Parser using the SLY library to parse SMILES strings.\n    \"\"\"\n\n    debugfile = \"parser.out\"\n    tokens = SmilesLex.tokens\n    use_only_grammar = False\n\n    def error(self, t):\n        raise Exception(f\"Error on {str(t)}\")\n\n    @_(\"atom\", \"atom chain_branch\")  # type: ignore\n    def line(self, rules):\n        return parser_manager.listify(*rules)\n\n    @_(\"chains\", \"branch\", \"chains chain_branch\", \"branch chain_branch\")  # type: ignore\n    def chain_branch(self, rules):\n        return parser_manager.listify(*rules)\n\n    @_(\"chain\", \"chain chains\")  # type: ignore\n    def chains(self, rules):\n        return parser_manager.listify(*rules)\n\n    @_('\"[\" internal_bracket \"]\"')  # type: ignore\n    def bracket_atom(self, rules):\n        return rules.internal_bracket\n\n    @_(*generate_combinations(\"isotope? symbol chiral? hcount? charge? mol_map?\"))  # type: ignore\n    def internal_bracket(self, rules):\n        return parser_manager.internal_bracket(\n            *getAttributes(\n                rules, [\"isotope\", \"symbol\", \"chiral\", \"hcount\", \"charge\", \"mol_map\"]\n            )\n        )\n\n    @_(\"dot_proxy\", \"bond atom\", \"bond rnum\", \"atom\", \"rnum\")  # type: ignore\n    def chain(self, rules):\n        return parser_manager.chain(\n            *getAttributes(rules, [\"bond\", \"atom\", \"rnum\", \"dot_proxy\"])\n        )\n\n    @_('\".\" atom')  # type: ignore\n    def dot_proxy(self, rules):\n        return parser_manager.dot_proxy(rules.atom)\n\n    @_(\"semi_symbol\", '\"H\"')  # type: ignore\n    def symbol(self, rules):\n        return rules[0]\n\n    @_('\"(\" inner_branch \")\"')  # type: ignore\n    def branch(self, rules):\n        return rules.inner_branch\n\n    @_(\"bond_dot line\", \"line\", \"bond_dot line inner_branch\", \"line inner_branch\")  # type: ignore\n    def inner_branch(self, rules):\n        return parser_manager.inner_branch(\n            *getAttributes(rules, [\"bond_dot\", \"line\", \"inner_branch\"])\n        )\n\n    @_(\"bond\", '\".\"')  # type: ignore\n    def bond_dot(self, rules):\n        return rules[0]\n\n    @_(\"semi_bond_rule\", '\"-\"')  # type: ignore\n    def bond(self, rules):\n        return rules[0]\n\n    @_(\"semi_bond\")  # type: ignore\n    def semi_bond_rule(self, rules):\n        return rules[0]\n\n    @_(\"symbol\", \"bracket_atom\")  # type: ignore\n    def atom(self, rules):\n        return parser_manager.atom(rules[0])\n\n    @_(\"digit\", '\"%\" digit digit ')  # type: ignore\n    def rnum(self, rules):\n        return parser_manager.ring_number(*rules)\n\n    @_(\"digit digit digit\", \"digit digit\", \"digit\")  # type: ignore\n    def isotope(self, rules):\n        return parser_manager.int(*rules)\n\n    @_('\"H\" digit', '\"H\"')  # type: ignore\n    def hcount(self, rules):\n        return parser_manager.hcount(*rules)\n\n    @_('\"+\"', '\"+\" \"+\"', '\"-\"', '\"-\" \"-\"', '\"-\" fifteen', '\"+\" fifteen')  # type: ignore\n    def charge(self, rules):\n        return parser_manager.charge(*rules)\n\n    @_('\":\" digit digit digit', '\":\" digit digit', '\":\" digit')  # type: ignore\n    def mol_map(self, rules):\n        return parser_manager.int(*rules[1:])\n\n    @_('\"@\"', '\"@\" \"@\"')  # type: ignore\n    def chiral(self, rules):\n        return parser_manager.chiral(*rules)\n\n    @_(\"digit digit\", \"digit\")  # type: ignore\n    def fifteen(self, rules):\n        return parser_manager.fifteen(*rules)\n</code></pre>"},{"location":"reference/validator/#validator.yacc.generate_combinations","title":"generate_combinations","text":"<pre><code>generate_combinations(rule: str) -&gt; list[str]\n</code></pre> <p>Generate all combinations of a rule with optional elements. Example:     rule = \"X? Y Z?\"     combinations = [ X Y Z, X Y, Y Z, Y ]</p> <p>Parameters:</p> Name Type Description Default <code>rule</code> <code>str</code> <p>A string with the rule to generate combinations from.</p> required <p>Returns:     A list of strings with all combinations of the rule.</p> Source code in <code>src/validator/yacc.py</code> <pre><code>def generate_combinations(rule: str) -&gt; list[str]:\n    \"\"\"\n    Generate all combinations of a rule with optional elements.\n    Example:\n        rule = \"X? Y Z?\"\n        combinations = [ X Y Z, X Y, Y Z, Y ]\n\n    Args:\n        rule: A string with the rule to generate combinations from.\n    Returns:\n        A list of strings with all combinations of the rule.\n    \"\"\"\n    parts = rule.split()\n\n    # Separate required and optional elements\n    required = [p.rstrip(\"?\") for p in parts if not p.endswith(\"?\")]\n    optional = [p.rstrip(\"?\") for p in parts if p.endswith(\"?\")]\n\n    all_combinations = []\n\n    for i in range(len(optional) + 1):\n        for combo in combinations(optional, i):\n            ordered_combo = [\n                p.rstrip(\"?\")\n                for p in parts\n                if p.rstrip(\"?\") in combo or p.rstrip(\"?\") in required\n            ]\n            all_combinations.append(\" \".join(ordered_combo))\n\n    return all_combinations\n</code></pre>"},{"location":"reference/validator/#validator.yacc.getAttributes","title":"getAttributes","text":"<pre><code>getAttributes(rules, properties)\n</code></pre> <p>Get the attributes of the rules. Args:     rules: The rules to get the attributes from.     properties: The properties to get the attributes from. Returns:     The attributes of the rules.</p> Source code in <code>src/validator/yacc.py</code> <pre><code>def getAttributes(rules, properties):\n    \"\"\"\n    Get the attributes of the rules.\n    Args:\n        rules: The rules to get the attributes from.\n        properties: The properties to get the attributes from.\n    Returns:\n        The attributes of the rules.\n    \"\"\"\n    if type(properties) != list:\n        return getattr(rules, properties, None)\n\n    values = []\n\n    for prop in properties:\n        values.append(getAttributes(rules, prop))\n\n    return values\n</code></pre>"},{"location":"reference/validator/#validator.yacc.validate_smiles","title":"validate_smiles","text":"<pre><code>validate_smiles(mol: str) -&gt; tuple[bool, Exception | None]\n</code></pre> <p>Function for valdiating a SMILES molecule.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>str</code> <p>Chemical formula as a string.</p> required <code>use_only_grammar</code> <p>For valdiating only the Grammar</p> required <p>Returns:</p> Type Description <code>tuple[bool, Exception | None]</code> <p>A Tuple containg in the first element if it is a valid SMILES and the second element a Exception.</p> Source code in <code>src/validator/yacc.py</code> <pre><code>def validate_smiles(mol: str) -&gt; tuple[bool, Exception | None]:\n    \"\"\"\n    Function for valdiating a SMILES molecule.\n\n    Args:\n        mol: Chemical formula as a string.\n        use_only_grammar: For valdiating only the Grammar\n\n    Returns:\n        A Tuple containg in the first element if it is a valid SMILES and the second element a Exception.\n    \"\"\"\n    try:\n        parser.parse(lexer.tokenize(mol))\n        parser_manager.validate_branch()\n        parser_manager._reset()\n        return True, None\n    except Exception as e:\n        raise e\n        return False, e\n</code></pre>"},{"location":"reference/validator/#validator.lex","title":"validator.lex","text":""},{"location":"reference/validator/#validator.lex.SmilesLex","title":"SmilesLex","text":"<p>               Bases: <code>Lexer</code></p> <p>Tokenizer for SMILES strings.</p> <p>Attributes:</p> Name Type Description <code>tokens</code> <p>A set of all tokens</p> <code>literals</code> <p>A set of all literals</p> <code>semi_symbol</code> <p>A regex for semi symbols</p> <code>semi_bond</code> <p>A regex for semi bonds</p> <code>digit</code> <p>A regex for digits</p> Source code in <code>src/validator/lex.py</code> <pre><code>class SmilesLex(Lexer):\n    \"\"\"\n    Tokenizer for SMILES strings.\n\n    Attributes:\n        tokens: A set of all tokens\n        literals: A set of all literals\n        semi_symbol: A regex for semi symbols\n        semi_bond: A regex for semi bonds\n        digit: A regex for digits\n    \"\"\"\n\n    literals = {\".\", \"@\", \"-\", \"+\", \":\", \"%\", \"H\", \")\", \"(\", \"]\", \"[\", \"H\"}\n\n    tokens = {\"semi_bond\", \"digit\", \"semi_symbol\"}\n\n    semi_symbol = rf\"{generate_regex_from_list(generate_lower(atoms))}\"\n    semi_bond = rf\"{generate_regex_from_list(bonds)}\"\n    digit = r\"\\d\"\n</code></pre>"},{"location":"reference/validator/#validator.lex.generate_lower","title":"generate_lower","text":"<pre><code>generate_lower(elem_list: list[str]) -&gt; list[str]\n</code></pre> <p>Generate a list of lower case elements from a list of elements and return both the lower and upper case elements.</p> <p>Parameters:</p> Name Type Description Default <code>elem_list</code> <code>list[str]</code> <p>A list of elements to generate a lower case list from.</p> required <p>Returns:     A list with all elements.</p> Source code in <code>src/validator/lex.py</code> <pre><code>def generate_lower(elem_list: list[str]) -&gt; list[str]:\n    \"\"\"\n    Generate a list of lower case elements from a list of elements and return both the lower and upper case elements.\n\n    Args:\n        elem_list: A list of elements to generate a lower case list from.\n    Returns:\n        A list with all elements.\n    \"\"\"\n    re_elem = []\n    for elem in elem_list:\n\n        re_elem.append(elem.lower())\n\n    return sorted(elem_list, reverse=True) + sorted(re_elem, reverse=True)\n</code></pre>"},{"location":"reference/validator/#validator.lex.generate_regex_from_list","title":"generate_regex_from_list","text":"<pre><code>generate_regex_from_list(elem_list: list[str]) -&gt; str\n</code></pre> <p>Generate a regex from a list of elements.</p> <p>Parameters:</p> Name Type Description Default <code>elem_list</code> <code>list[str]</code> <p>A list of elements to generate a regex from.</p> required <p>Returns:     A regex string that matches any of the elements in the list.</p> Source code in <code>src/validator/lex.py</code> <pre><code>def generate_regex_from_list(elem_list: list[str]) -&gt; str:\n    \"\"\"\n    Generate a regex from a list of elements.\n\n    Args:\n        elem_list: A list of elements to generate a regex from.\n    Returns:\n        A regex string that matches any of the elements in the list.\n    \"\"\"\n    re_elem = []\n    for elem in elem_list:\n        re_elem.append(re.escape(elem))\n\n    return \"|\".join(re_elem)\n</code></pre>"}]}